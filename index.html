<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Global Solar Utilization Heatmap</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    html, body { height:100%; margin:0; }
    #controls {
      position:absolute; top:0; left:0; right:0; height:50px;
      background:#fff; z-index:1000; padding:8px; font-family:sans-serif;
    }
    #map { position:absolute; top:50px; bottom:0; width:100%; }
    label { margin-right:20px; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Solar (GW):
      <select id="solarSelect"></select>
    </label>
    <label>Battery (GWh):
      <select id="batterySelect"></select>
    </label>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
  // derive base URL for CSVs
  const url = new URL(window.location.href);
  const dir = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
  const baseUrl = `${url.origin}${dir}`;

  // 1) init map
  const map = L.map('map').setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution:'© OpenStreetMap contributors'
  }).addTo(map);
  let interpLayer = null;

  // 2) dropdowns
  const solarSelect = document.getElementById('solarSelect');
  const batterySelect = document.getElementById('batterySelect');
  for(let i=1;i<=10;i++){
    const o=document.createElement('option');
    o.value=i; o.text=i+' GW';
    solarSelect.add(o);
  }
  for(let j=1;j<=15;j++){
    const o=document.createElement('option');
    o.value=j; o.text=j+' GWh';
    batterySelect.add(o);
  }
  solarSelect.value=1;
  batterySelect.value=1;

  // 3) data holders
  let locationsMap = {}, utilRows = [], utilIndexKey = '';
  let landPolygons = null;

  // 4) load land mask
  fetch('https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson')
    .then(r=>r.json())
    .then(js=>{
      landPolygons = js;
      loadLocations();
    })
    .catch(err=>console.error('land load error',err));

  function loadLocations(){
    fetch(baseUrl+'locations_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{header:true,dynamicTyping:true,complete(res){
          utilIndexKey = res.meta.fields[0];
          res.data.forEach(r=>{
            const k=r[utilIndexKey];
            if(k!=null) locationsMap[k]={lat:r.lat,lon:r.lon};
          });
          loadUtil();
        }});
      })
      .catch(err=>console.error('locations CSV error',err));
  }

  function loadUtil(){
    fetch(baseUrl+'utilization_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{header:true,dynamicTyping:true,complete(res){
          utilIndexKey = res.meta.fields[0];
          utilRows = res.data.filter(r=>r[utilIndexKey]!=null);
          drawHeatmap();
        }});
      })
      .catch(err=>console.error('util CSV error',err));
  }

  // 5) interpolation & draw
  function drawHeatmap(){
    if(!landPolygons || !utilRows.length) return;

    const s=solarSelect.value, b=batterySelect.value;
    const colKey = `${s}GW_${b}GWh`;

    // build Turf points
    const pts = utilRows.map(r=>{
      const v=r[colKey], k=r[utilIndexKey], c=locationsMap[k];
      return c && v!=null ? turf.point([c.lon,c.lat],{value:v}) : null;
    }).filter(x=>x);

    if(pts.length < 3){
      console.warn('Need ≥3 points to interpolate, got',pts.length);
      return;
    }

    const fc = turf.featureCollection(pts);
    const cellSize = 2; // deg
    const grid = turf.interpolate(fc, cellSize, {
      gridType:'point',
      property:'value',
      units:'degrees',
      weight:2
    });
    if(!grid || !grid.features){
      console.error('Interpolation failed');
      return;
    }

    // keep only land cells
    const landPts = grid.features.filter(pt=>{
      return turf.booleanPointInPolygon(pt, landPolygons);
    });

    // remove old
    if(interpLayer) map.removeLayer(interpLayer);

    // draw new
    interpLayer = L.layerGroup(
      landPts.map(pt=>{
        const [lon,lat]=pt.geometry.coordinates;
        const v=pt.properties.value;
        // color: red→blue
        const hue=(1-v)*240;
        return L.circleMarker([lat,lon],{
          radius:  cellSize*0.6,
          stroke:  false,
          fillOpacity: 1.0,
          fillColor: `hsl(${hue},100%,50%)`
        });
      })
    ).addTo(map);
  }

  solarSelect.addEventListener('change',drawHeatmap);
  batterySelect.addEventListener('change',drawHeatmap);
  </script>
</body>
</html>
