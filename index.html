<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Global Solar Utilization Choropleth</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    html,body { height:100%; margin:0 }
    #controls {
      position:absolute; top:0; left:0; right:0; height:50px;
      background:#fff; z-index:1000; padding:8px; font-family:sans-serif;
    }
    #map { position:absolute; top:50px; bottom:0; width:100% }
    label { margin-right:20px }
  </style>
</head>
<body>
  <div id="controls">
    <label>Solar (GW):
      <select id="solarSelect"></select>
    </label>
    <label>Battery (GWh):
      <select id="batterySelect"></select>
    </label>
  </div>
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- PapaParse -->
  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <!-- Turf -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <script>
  // derive base URL for CSVs
  const url = new URL(window.location.href);
  const dir = url.pathname.slice(0, url.pathname.lastIndexOf('/')+1);
  const baseUrl = url.origin + dir;

  // 1) init map
  const map = L.map('map').setView([20,0],2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution:'© OpenStreetMap contributors'
  }).addTo(map);

  // dropdowns
  const solarSelect = document.getElementById('solarSelect');
  const batterySelect = document.getElementById('batterySelect');
  for(let i=1;i<=10;i++){
    const o=document.createElement('option');
    o.value=i; o.text=i+' GW'; solarSelect.add(o);
  }
  for(let j=1;j<=15;j++){
    const o=document.createElement('option');
    o.value=j; o.text=j+' GWh'; batterySelect.add(o);
  }
  solarSelect.value=1;
  batterySelect.value=1;

  // data holders
  let locationsMap={}, utilRows=[], utilIndexKey='';
  let landPolygons=null, cellsLayer=null;

  // color ramp: 0→blue, 1→red
  function getColor(v){
    const h = (1 - v)*240;
    return `hsl(${h},100%,50%)`;
  }

  // 2) load land mask
  fetch('https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson')
    .then(r=>r.json())
    .then(js=>{
      landPolygons = js;
      loadLocations();
    })
    .catch(e=>console.error('land load error',e));

  // 3) load locations CSV
  function loadLocations(){
    fetch(baseUrl + 'locations_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{
          header:true, dynamicTyping:true,
          complete(res){
            utilIndexKey = res.meta.fields[0];
            res.data.forEach(r=>{
              const k=r[utilIndexKey];
              if(k!=null) locationsMap[k]={lat:r.lat,lon:r.lon};
            });
            loadUtil();
          }
        });
      })
      .catch(e=>console.error('locations CSV error',e));
  }

  // 4) load utilization CSV
  function loadUtil(){
    fetch(baseUrl + 'utilization_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{
          header:true, dynamicTyping:true,
          complete(res){
            utilIndexKey = res.meta.fields[0];
            utilRows = res.data.filter(r=>r[utilIndexKey]!=null);
            renderChoropleth();
          }
        });
      })
      .catch(e=>console.error('util CSV error',e));
  }

  // 5) build & render Voronoi + IDW
  function renderChoropleth(){
    if(!landPolygons || !utilRows.length) return;
    // clear old
    if(cellsLayer) map.removeLayer(cellsLayer);

    // build Turf points with values
    const s=solarSelect.value, b=batterySelect.value;
    const colKey = `${s}GW_${b}GWh`;
    const pts = [];
    utilRows.forEach(r=>{
      const k=r[utilIndexKey], v=r[colKey], c=locationsMap[k];
      if(c && v!=null){
        const p = turf.point([c.lon,c.lat], { value: v });
        pts.push(p);
      }
    });
    if(pts.length < 3){
      console.warn('Need at least 3 sites; got', pts.length);
      return;
    }
    const fc = turf.featureCollection(pts);

    // compute Voronoi cells
    const vor = turf.voronoi(fc, { bbox: [-180,-90,180,90] });
    if(!vor || !vor.features){
      console.error('Voronoi failed');
      return;
    }

    // for each cell: IDW at centroid + clip to land
    const cells = [];
    vor.features.forEach(cell=>{
      if(!cell) return;
      // centroid for interpolation
      const cpt = turf.centroid(cell);
      // compute distances to all pts
      const arr = pts.map((p,i)=>({
        d: turf.distance(cpt, p, {units:'kilometers'}),
        v: p.properties.value
      }));
      arr.sort((a,b)=>a.d-b.d);
      // IDW over nearest 3
      let sw=0, swv=0;
      for(let i=0;i<3 && i<arr.length;i++){
        const w = 1/(arr[i].d + 1e-6);
        sw  += w;
        swv += w * arr[i].v;
      }
      const vi = swv/sw;
      // clip cell to land
      const clip = turf.intersect(cell, landPolygons);
      if(clip){
        clip.properties.value = vi;
        cells.push(clip);
      }
    });

    // add to map
    cellsLayer = L.geoJSON(
      turf.featureCollection(cells),
      {
        style: f => ({
          fillColor: getColor(f.properties.value),
          fillOpacity: 1.0,
          stroke: false
        })
      }
    ).addTo(map);
  }

  solarSelect  .addEventListener('change', renderChoropleth);
  batterySelect.addEventListener('change', renderChoropleth);
  </script>
</body>
</html>
