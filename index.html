<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Global Solar Utilization Heatmap</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet/dist/leaflet.css"
  />
  <style>
    html, body { height:100%; margin:0; }
    #controls {
      position:absolute; top:0; left:0; right:0; height:50px;
      background:#fff; z-index:1000; padding:8px; font-family:sans-serif;
    }
    #map { position:absolute; top:50px; bottom:0; width:100%; }
    label { margin-right:20px; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Solar (GW):
      <select id="solarSelect"></select>
    </label>
    <label>Battery (GWh):
      <select id="batterySelect"></select>
    </label>
  </div>
  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Heat plugin (unused here but retained) -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <!-- PapaParse -->
  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <!-- Turf.js for interpolation & geo ops -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <script>
  // — derive base URL —
  const url = new URL(window.location.href);
  const dir = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
  const baseUrl = `${url.origin}${dir}`;

  // — init map —
  const map = L.map('map').setView([20,0],2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution:'© OpenStreetMap contributors'
  }).addTo(map);

  // — dropdowns —
  const solarSelect = document.getElementById('solarSelect');
  const batterySelect = document.getElementById('batterySelect');
  for(let i=1;i<=10;i++){
    const o=document.createElement('option');
    o.value=i; o.text=i+' GW';
    solarSelect.add(o);
  }
  for(let j=1;j<=15;j++){
    const o=document.createElement('option');
    o.value=j; o.text=j+' GWh';
    batterySelect.add(o);
  }
  solarSelect.value=1;
  batterySelect.value=1;

  // — data holders —
  let locationsMap={}, utilRows=[], utilIndexKey='';
  let landPolygons=null;
  let interpLayer=null;

  // — color scale: map [0,1]→hue 240°(blue)→0°(red) —
  function getColor(v){
    const hue = (1-v)*240;
    return `hsl(${hue},100%,50%)`;
  }

  // — fetch land GeoJSON (all countries → land) —
  fetch('https://raw.githubusercontent.com/datasets/geo-boundaries-world-110m/master/countries.geojson')
    .then(r=>r.json())
    .then(js=>{
      landPolygons = js;
      loadLocations();
    })
    .catch(e=>console.error('Failed to load land polygons:', e));

  function loadLocations(){
    fetch(baseUrl + 'locations_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{header:true,dynamicTyping:true,complete(res){
          utilIndexKey = res.meta.fields[0];
          res.data.forEach(r=>{
            const k = r[utilIndexKey];
            if(k!=null) locationsMap[k] = {lat:r.lat,lon:r.lon};
          });
          loadUtil();
        }});
      })
      .catch(e=>console.error('Failed to load locations:',e));
  }

  function loadUtil(){
    fetch(baseUrl + 'utilization_100locs.csv')
      .then(r=>r.text())
      .then(txt=>{
        Papa.parse(txt,{header:true,dynamicTyping:true,complete(res){
          utilIndexKey = res.meta.fields[0];
          utilRows = res.data.filter(r=>r[utilIndexKey]!=null);
          renderInterpolation();
        }});
      })
      .catch(e=>console.error('Failed to load utilization:',e));
  }

  function renderInterpolation(){
    // remove old
    if(interpLayer) map.removeLayer(interpLayer);

    // prepare point features
    const s = solarSelect.value, b = batterySelect.value;
    const key = `${s}GW_${b}GWh`;
    const pts = utilRows.map(r=>{
      const v = r[key];
      const c = locationsMap[r[utilIndexKey]];
      return (c && v!=null)
        ? turf.point([c.lon,c.lat],{value:v})
        : null;
    }).filter(x=>x);

    // IDW interpolate on a 2° grid
    const fc = turf.featureCollection(pts);
    const cellSize = 2; // degrees
    const grid = turf.interpolate(fc, cellSize, {
      gridType: 'point',
      property: 'value',
      units: 'degrees'
    });

    // clip to land
    const onLand = grid.features.filter(f=>{
      return turf.booleanPointInPolygon(f, landPolygons);
    });

    // convert to GeoJSON and style as small squares
    const squareSize = cellSize * 1000; // approximate px radius
    interpLayer = L.layerGroup(
      onLand.map(f=>{
        const [lon,lat] = f.geometry.coordinates;
        const v = f.properties.value;
        return L.circleMarker([lat,lon],{
          radius:  cellSize*0.7,
          stroke:  false,
          fillOpacity: 1.0,
          fillColor: getColor(v)
        });
      })
    ).addTo(map);
  }

  solarSelect  .addEventListener('change', renderInterpolation);
  batterySelect.addEventListener('change', renderInterpolation);
  </script>
</body>
</html>
